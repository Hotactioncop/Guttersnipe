#include <vector>
#include <memory>
#include <map>
#include <functional>
#include <cmath>
#include <iostream>
#include <string>
#include <utility>
#include <iterator>
#include <regex>
#include <cmath>
#include <ostream>
#include <istream>
#include "Header.h"
#include "A.h"
#include "Book.h"
#include <set>
#include <tuple>
#include <cstdlib>
#include "human.h"

using namespace std;
#define stop __asm nop

int main()
{
	setlocale(LC_ALL, "RUSSIAN");
	//////////////////////////////////////////////////////////////////////////////////////////////
	//Задание 1. Регулярные выражения


	// 1a Обеспечить прием от пользователя целых значений в десятичной форме.
	// Необходимо учесть специфику пользователя, который должен ввести целое,
	//				а может ввести все, что угодно,
	//				число может предворяться знаком -/+,
	//				количество цифр может быть любым (в частности может превышать sizeof(int))
	//				
	//Подсказки:
	//			a) std::string может принять строчку с любым содержимым
	//			б) нужно проанализировать, соответствует ли введенное значение целому в допустимом диапазоне
	//			в) и, если соответствует, перевести из строкового представления в значение типа int
	//					(для преобразования удобно использовать С++11 - std::stoi())

	{
		//string _nstr;
		//cin >> _nstr;
		//regex _re("(\\+|\\-)?[0-2147483647]");
		//int _numb;
		//if (regex_match(_nstr, _re))
		//{
		//	_numb = stoi(_nstr);
		//}
		//cout << _numb;
		//stop
	}
	// 1b ООбеспечить прием от пользователя целых значений в шестнадцатеричной форме.
	{
		//string _nstr1;
		//cin >> _nstr1;
		//regex _re1("[A-Fa-f0-9]{8}");
		//stop

	}
	// 1с Обеспечить прием от пользователя плавающих значений в форматах
	//      -2.33 или +1.23e+06 или 0.245E10
	{
		//string _nstr2;
		//cin >> _nstr2;
		//double _numb2;
		//regex _re2("(\\+|\\-)?[0-9]\.[0-9]*((e\\+|E)?[0-9]{2})?");
		//if (regex_match(_nstr2, _re2))
		//{
		//	_numb2 = strtod(_nstr2.c_str(), NULL);
		//}
		//cout << _numb2;
		//stop
	}
	//1d Требуется узнать - есть ли хотя бы одна десятичная цифра в строке
	{
		//string _nstr3;
		//cin >> _nstr3;
		//regex _re3("[0-9]");
		//cmatch _numb3;
		//if (regex_search(_nstr3.c_str(), _numb3, _re3))
		//{
		//	for (int i = 0; i < _numb3.size(); i++)
		//	{
		//		cout << _numb3[i] << " ";
		//	}
		//}

		//__asm nop
	}


		//1e Требуется найти все десятичные цифры в строке
	{
		//string _nstr4;
		//cin >> _nstr4;
		//regex _re4("[0-9]*");
		//cmatch _numb4;
		//regex_iterator<string::iterator> itBegin(_nstr4.begin(), _nstr4.end(), _re4);
		//regex_iterator<string::iterator> itEnd;
		//while (itBegin != itEnd)
		//{
		//	std::cout << itBegin->str();
		//	++itBegin;
		//}

		//__asm nop


	}
	////////////////////////////////////////////////////////////////////////////////
	//Задание 2 variadictemplate - функция
	//Реализуйте функцию, которая умеет печатать любое количество параметров любого типа,
	//Например: MyPrint(4,8.8, A(1),std::string("dfg") );
	{
		MyPrint(4, 8.8, A(1), std::string("dfg"));


		__asm nop
	}
	////////////////////////////////////////////////////////////////////////////////
	//Задание 3 function
	//3a Реализуйте "калькулятор", который будет выполнять простейшие действия: +,-,*,/,^
	//     над операндами типа double:
	// '+' - посредством шаблона глобальной функции
	// '-' - посредством шаблона std::minus
	// '*' - посредством функционального объекта 
	// '/' - посредством лямбда-функции
	// '^' - посредством функции pow() (перегруженный вариант для double)
	// '%' - дробную часть от результата плавающего деления посредством std::bind()
	//* '?' - наибольшее из двух значений посредством std::bind() и метода Вашего класса  
	// 
	//Для хранения значка операции и соответствующего ему действия логично использовать
	//std::map<char, ???>
	{
		function<double(double, double)> _lamb = [](double x, double y) {return x / y; };
		auto Mod = std::bind(_div, placeholders::_1, placeholders::_2);
		auto Max = bind(&bigger::_max, bigger(), placeholders::_1, placeholders::_2);
		std::map<char, function<double(double,double)>> m_fun;
		m_fun.emplace(make_pair('+', _plus<double>));
		m_fun.emplace(make_pair('-', minus<double>()));
		m_fun.emplace(make_pair('*', product()));
		m_fun.emplace(make_pair('/', _lamb));
		m_fun.emplace(make_pair('^', _pow));
		m_fun.emplace(make_pair('%', Mod));
		m_fun.emplace(make_pair('?', Max));
		cout << endl;
		for (auto&x : m_fun)
		{
			cout << x.first << "\t" << x.second(10.5, 5.3) << endl;
		}
		__asm nop
	}

	//3б Рекурсивная лямбда функция. Посредством std::function и лямбда функции реализуйте
	//вычисление суммы натурального ряда (x+(x-1)+ (x-2)+...+1).
	//Подсказка: так как существование любой переменной начинается с момента определения, 
	//например: int x=x; - бессмысленно, но корректно
	// => переменную типа function можно использовать в списке захвата  - ... f = [&f]...
	{
		std::function<int(int)> f = [&f](int i) {return (i) ? i + f(i - 1) : 1; };
		cout << f(5);
		__asm nop

	}

	//////////////////////////////////////////////////////////////////////////////////
	//Задание 4 std::tuple
	//Создайте класс book (автор, заглавие, год издания...). 
	//Создайте библиотеку таким образом, чтобы книги хранились в упорядоченном виде.
	//Чтобы упорядочить совокупность книжек, нужно сформировать условие сравнения, то есть
	//перегрузить, например operator<. При реализации оператора хочется сформировать условие
	//с учетом всех данных!!! 

	//Подсказка: Для упорядочения удобно использовать шаблон std::tuple,
	//так как для std::tuple перегружены операторы ==,!=,<,<=,>,>=
	//,которые сравнивают два кортежа лексиграфически (в порядке следования членов).


	//Для проверки распечатайте библиотеку

	{
		set<Book> Bread;
		Bread.insert(Book("Александр Пушкин", "Сказка о рыбаке и рыбке", 1812));
		Bread.insert(Book("Михаил Булгаков", "Мастер и Маргарита", 1940));
		Bread.insert(Book("Николай Лесков", "Левша", 1881));
		Bread.insert(Book("Лев Толстой", "Война и мир", 1868));
		Bread.insert(Book("Иван Тургенев", "Записки охотника", 1852));
		Bread.insert(Book("Алексей Толстой", "Хождение по мукам", 1841));
		Bread.insert(Book("Александр Беляев", "Голова профессора Доуэля", 1925));
		Bread.insert(Book("Михаил Булгаков", "Собачье сердце", 1925));
		Bread.insert(Book("Доктор Живаго", "Борис Пастернак", 1955));
		Bread.insert(Book("Михаил Лермонтов", "Герой нашего времени", 1840));
		Bread.insert(Book("Антон Чехов", "Палата№6", 1892));

		cout << Bread;
		__asm nop

	}

	/////////////////////////////////////////////////////////////////
	//Задание 5. shared_ptr и weak_ptr
	//Создаем генеалогическое дерево посредством класса human. В классе хранятся:
	//имя - string
	//возможно признак: жив или уже нет...
	//родители - shared_ptr (родители не всегда известны...)
	//дети - контейнер из weak_ptr (чтобы избежать циклических зависимостей)

	//Методы класса human:
	//конструктор - для инициализации имени и признака
	//конструктор копирования, оператор присваивания, move ???
	//статический метод child() - 
	//				должен создать создать и вернуть обертку для родившегося человека
	//				+ сформировать все связи ребенка с родителями и наоборот

	//Ввести возможность распечатать генеалогическое дерево для указанного индивидума

	{
		//История должна с кого-то начинаться => "Жили-были дед да баба, например, Адам и Ева"
		//(то есть на самом деле два деда и две бабы):


		//std::shared_ptr<human> grandM1(new human("Eva"));
		//...

		//у них появились дети - child():


		//а у детей в свою очередь свои дети:
		human first("Eva", no);
		human second("Adam", no);
		human third = human::child("Edvard", yes, &first, &second);

		//...
		__asm nop
	}


}

